use std::sync::Arc;

use axum::{
    Extension,
    http::StatusCode,
    response::{IntoResponse, Json},
};
use moneymq_types::x402::{FacilitatorErrorReason, Network, VerifyRequest, VerifyResponse};
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_commitment_config::CommitmentConfig;
use tracing::{debug, error, info, warn};

use crate::{
    api::payment::{
        PaymentApiConfig,
        endpoints::{
            channels::{
                BasketItem, ChannelEvent, PaymentDetails, PaymentFailedData, PaymentVerifiedData,
                TransactionNotification,
            },
            serialize_to_base64,
        },
        networks,
    },
    events::{
        PaymentFlow, PaymentVerificationFailedData, PaymentVerificationSucceededData,
        create_payment_verification_failed_event, create_payment_verification_succeeded_event,
    },
};

/// POST /verify endpoint - verify a payment payload
pub async fn handler(
    Extension(state): Extension<PaymentApiConfig>,
    Json(request): Json<VerifyRequest>,
) -> impl IntoResponse {
    debug!("Verify endpoint called");

    debug!(
        "Verify endpoint: PaymentApiConfig loaded, payment_stack_id={}",
        state.payment_stack_id
    );

    debug!(
        "Received verify request for network: {:?}",
        request.payment_requirements.network
    );

    // Verify network matches
    let Some(network_config) =
        state
            .facilitator_config
            .networks
            .iter()
            .find_map(|(_, network_config)| {
                network_config
                    .network()
                    .eq(&request.payment_requirements.network)
                    .then_some(network_config)
            })
    else {
        debug!(
            "Invalid network in verify request: {:?}",
            request.payment_requirements.network
        );
        return (
            StatusCode::BAD_REQUEST,
            Json(VerifyResponse::Invalid {
                reason: FacilitatorErrorReason::InvalidNetwork,
                payer: None,
            }),
        );
    };

    // Verify payment payload network matches requirements
    if request.payment_payload.network != request.payment_requirements.network {
        debug!(
            "Payment payload network does not match requirements: {:?} != {:?}",
            request.payment_payload.network, request.payment_requirements.network
        );
        return (
            StatusCode::BAD_REQUEST,
            Json(VerifyResponse::Invalid {
                reason: FacilitatorErrorReason::InvalidNetwork,
                payer: None,
            }),
        );
    }

    // Delegate to network-specific verification
    let (status, response) = match network_config.network() {
        Network::Solana => {
            let rpc_client = Arc::new(RpcClient::new_with_commitment(
                network_config.rpc_url().to_string(),
                CommitmentConfig::confirmed(),
            ));
            match networks::solana::verify_solana_payment(
                &request,
                &rpc_client,
                &state.kora_config,
                &state.signer_pool,
            )
            .await
            {
                Ok(response) => (StatusCode::OK, response),
                Err(e) => {
                    error!("Verification failed: {}", e);
                    (
                        StatusCode::BAD_REQUEST,
                        VerifyResponse::Invalid {
                            reason: FacilitatorErrorReason::FreeForm(e.to_string()),
                            payer: None,
                        },
                    )
                }
            }
        }
    };

    let verify_request_base64 = serialize_to_base64(&request);
    let verify_response_base64 = serialize_to_base64(&response);
    let payment_requirement_base64 = serialize_to_base64(&request.payment_requirements);

    match state.db_manager.insert_transaction(
        &request,
        &response,
        payment_requirement_base64,
        verify_request_base64,
        verify_response_base64,
        &state.payment_stack_id,
        state.is_sandbox,
    ) {
        Ok(_) => {
            debug!("Transaction inserted successfully into database");
        }
        Err(e) => {
            error!("Failed to log transaction to database: {}", e);
        }
    };

    // Extract product_id and transaction_id from payment requirements extra metadata
    let product_id = request
        .payment_requirements
        .extra
        .as_ref()
        .and_then(|extra| extra.get("product"))
        .and_then(|v| v.as_str())
        .map(|s| s.to_string());

    // Get transaction ID from extra context (generated by middleware)
    let transaction_id = request
        .payment_requirements
        .extra
        .as_ref()
        .and_then(|extra| extra.get("transactionId"))
        .and_then(|v| v.as_str())
        .map(|s| s.to_string());

    // Debug: log extra context to see what keys are present
    if let Some(ref extra) = request.payment_requirements.extra {
        info!(
            "Verify extra context keys: {:?}",
            extra.as_object().map(|o| o.keys().collect::<Vec<_>>())
        );
        info!("Verify transaction_id extracted: {:?}", transaction_id);
    } else {
        warn!("Verify: No extra context in payment requirements");
    }

    // Emit CloudEvent for verification result (legacy event stream)
    if let Some(ref sender) = state.event_sender {
        let event = match &response {
            VerifyResponse::Valid { payer } => {
                let event_data = PaymentVerificationSucceededData {
                    payer: payer.to_string(),
                    amount: request.payment_requirements.max_amount_required.0.clone(),
                    network: format!("{:?}", request.payment_requirements.network),
                    product_id: product_id.clone(),
                    payment_flow: PaymentFlow::X402,
                };
                create_payment_verification_succeeded_event(event_data)
            }
            VerifyResponse::Invalid { reason, payer } => {
                let event_data = PaymentVerificationFailedData {
                    payer: payer.as_ref().map(|p| p.to_string()),
                    amount: request.payment_requirements.max_amount_required.0.clone(),
                    network: format!("{:?}", request.payment_requirements.network),
                    reason: format!("{:?}", reason),
                    product_id: product_id.clone(),
                    payment_flow: PaymentFlow::X402,
                };
                create_payment_verification_failed_event(event_data)
            }
        };
        if let Err(e) = sender.send(event) {
            error!("Failed to send verification event: {}", e);
        }
    }

    // Publish to channel (new channel-based event system)
    if let (Some(channel_manager), Some(tx_id)) = (&state.channel_manager, &transaction_id) {
        // Extract network name
        let network = format!("{:?}", request.payment_requirements.network).to_lowercase();
        let amount_str = request.payment_requirements.max_amount_required.0.clone();
        let currency = "USDC".to_string(); // TODO: extract from payment requirements

        match &response {
            VerifyResponse::Valid { payer } => {
                // Extract basket from extra.product (stored as JSON string array)
                // and features from extra.features
                let features_value = request
                    .payment_requirements
                    .extra
                    .as_ref()
                    .and_then(|extra| extra.get("features"))
                    .cloned()
                    .unwrap_or(serde_json::Value::Object(serde_json::Map::new()));

                let basket: Vec<BasketItem> = request
                    .payment_requirements
                    .extra
                    .as_ref()
                    .and_then(|extra| extra.get("product"))
                    .and_then(|v| v.as_str())
                    .and_then(|s| serde_json::from_str::<Vec<serde_json::Value>>(s).ok())
                    .map(|items| {
                        items
                            .iter()
                            .filter_map(|item| {
                                let product_id = item.get("productId")?.as_str()?.to_string();
                                let experiment_id = item
                                    .get("experimentId")
                                    .and_then(|v| v.as_str())
                                    .filter(|s| !s.is_empty())
                                    .map(|s| s.to_string());
                                let quantity =
                                    item.get("quantity").and_then(|v| v.as_u64()).unwrap_or(1)
                                        as u32;

                                Some(BasketItem {
                                    product_id,
                                    experiment_id,
                                    features: features_value.clone(),
                                    quantity,
                                })
                            })
                            .collect()
                    })
                    .unwrap_or_default();

                // Build payment details
                let payment = PaymentDetails {
                    payer: payer.to_string(),
                    transaction_id: tx_id.clone(),
                    amount: amount_str.clone(),
                    currency: currency.clone(),
                    network: network.clone(),
                };

                // Notify transaction stream FIRST so receivers can set up actors
                let notification = TransactionNotification {
                    id: tx_id.clone(),
                    channel_id: tx_id.clone(),
                    basket,
                    payment: Some(payment),
                    metadata: request.payment_requirements.extra.clone(),
                };
                channel_manager.notify_transaction(notification);

                // Then publish payment:verified to the transaction's channel
                let channel_event = ChannelEvent::payment_verified(PaymentVerifiedData {
                    payer: payer.to_string(),
                    amount: amount_str.clone(),
                    network: network.clone(),
                    product_id: product_id.clone(),
                });
                channel_manager.publish(tx_id, channel_event);
            }
            VerifyResponse::Invalid { reason, payer } => {
                let channel_event = ChannelEvent::payment_failed(PaymentFailedData {
                    payer: payer.as_ref().map(|p| p.to_string()),
                    amount: amount_str.clone(),
                    network: network.clone(),
                    reason: Some(format!("{:?}", reason)),
                    product_id: product_id.clone(),
                });
                channel_manager.publish(tx_id, channel_event);
            }
        }
    }

    (status, Json(response))
}
